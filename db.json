{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/anatole/source/css/blog_basic.css","path":"css/blog_basic.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/style.css.map","path":"css/style.css.map","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/logo-old.png","path":"images/logo-old.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/js/jquery.appear.js","path":"js/jquery.appear.js","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/js/jquery-migrate-1.2.1.min.js","path":"js/jquery-migrate-1.2.1.min.js","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/logo@2x.png","path":"images/logo@2x.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/logo@2x-old.png","path":"images/logo@2x-old.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/anatole/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/images/favicon-32x32.png","path":"images/favicon-32x32.png","modified":0,"renderable":0},{"_id":"source/images/side.jpg","path":"images/side.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/anatole/_config.yml","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513098195000},{"_id":"themes/anatole/LICENSE","hash":"359cb81298c1fdbccf531548fc097466b0151be4","modified":1512565230000},{"_id":"themes/anatole/README.md","hash":"75a3829b8a316249ec0b4fd8eae2d371de879494","modified":1512565230000},{"_id":"themes/anatole/package.json","hash":"cf731a3ebf3913747fccb6c4c6615eba7d7e88a4","modified":1512565230000},{"_id":"themes/anatole/.DS_Store","hash":"622fadec9ff8301c000487f21eeca22ec7494327","modified":1512937800000},{"_id":"source/_posts/Primeiro-Post.md","hash":"42ea8a11a132de5dd5c128bc34400afef32f803a","modified":1512929295000},{"_id":"source/_posts/Brincando-com-colecoes-reativas-em-c.md","hash":"fcc86e15f84fb798664880a11b17c19449274e9b","modified":1513099523000},{"_id":"source/about/index.md","hash":"f8851d72d67fecd3ec7bc6de11291e3ed774a8f6","modified":1513099497000},{"_id":"themes/anatole/languages/zh-cn.yml","hash":"dab1823e036f4adb3b7ae9efe95a37a15e47bec2","modified":1512565230000},{"_id":"themes/anatole/languages/pt-BR.yml","hash":"ac5a0003d7793aade51f70643b2e2a631b6a65c3","modified":1512565230000},{"_id":"themes/anatole/layout/archive.jade","hash":"1a161404966000b25a84762f08da3ca60af146bc","modified":1512565230000},{"_id":"themes/anatole/layout/category.jade","hash":"ae894ef4baee4a0c7c8e66641166061e789f1fa7","modified":1512565230000},{"_id":"themes/anatole/layout/index.jade","hash":"53da3cfd498951148acb33de1574df80ae282dc5","modified":1512565230000},{"_id":"themes/anatole/layout/mixins.jade","hash":"107bfd2fe10de0d8b110c13bb1168af79e62a37c","modified":1512565230000},{"_id":"themes/anatole/layout/post.jade","hash":"2f2b91b98d8f72d105211cdbf312d44ea3b1b145","modified":1512565230000},{"_id":"themes/anatole/layout/page.jade","hash":"15142c94e5c2247aba8efb64cffd695b3f133670","modified":1512565230000},{"_id":"themes/anatole/layout/tag.jade","hash":"7017a8bae4f4a412dafb556772bdcf2cfddeb79f","modified":1512565230000},{"_id":"themes/anatole/source/.DS_Store","hash":"b8902c26012842abf6357774b596e58ab3cf2956","modified":1512934912000},{"_id":"themes/anatole/layout/partial/comments.jade","hash":"576804dbc178bcdf65e89bd5f30acd4309994f83","modified":1512565230000},{"_id":"themes/anatole/layout/partial/head.jade","hash":"0646a7b07347c33ea2a545b0db9dec54429c8a2f","modified":1512938384000},{"_id":"themes/anatole/layout/partial/layout.jade","hash":"d05acd6cc0642f0a299fcbbb89c3913777cac1fc","modified":1513100776000},{"_id":"themes/anatole/layout/partial/footer.jade","hash":"021203507580ecb6e6943107231a324c3e3c7645","modified":1513098962000},{"_id":"themes/anatole/layout/partial/sidebar.jade","hash":"6721b1e0b1e59e54d031a4978e7f82aece336efc","modified":1512565230000},{"_id":"themes/anatole/layout/partial/nav.jade","hash":"32a0f2cb9d7477b61b5d5c313abadc401c1a281a","modified":1513101174000},{"_id":"themes/anatole/source/css/blog_basic.css","hash":"1ec8757e65f87754b35c48f8333a328080a8483e","modified":1512938273000},{"_id":"themes/anatole/source/css/font-awesome.min.css","hash":"95d0b0c4d11105c81be1857b744076a1d2bed918","modified":1512565230000},{"_id":"themes/anatole/source/css/style.scss","hash":"4ce8a58cc93bf8c84038f9fe24efbd822e5b3632","modified":1513101719000},{"_id":"themes/anatole/source/css/style.css","hash":"1aa1099242d84a8734c48d879dc5a9f9e0d74dc7","modified":1513101727000},{"_id":"themes/anatole/source/css/style.css.map","hash":"d607c721f94ebc64974f29e3a869fe293cf54a67","modified":1513101644000},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1512565230000},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1512565230000},{"_id":"themes/anatole/source/images/.DS_Store","hash":"cc533801b4d4e5d909799a61bab003fefb0c4d37","modified":1512934952000},{"_id":"themes/anatole/source/images/logo-old.png","hash":"41bdf2ebd8cc193ad82a211758af827d891b1a90","modified":1512565230000},{"_id":"themes/anatole/source/js/jquery.appear.js","hash":"1f8067d7bd4c0bde30785e8016100f239e14394f","modified":1512565230000},{"_id":"themes/anatole/source/images/favicon.png","hash":"d659236704308954da9d64b101c4f54cc3f3255c","modified":1512565230000},{"_id":"themes/anatole/source/js/jquery-migrate-1.2.1.min.js","hash":"743052320809514fb788fe1d3df37fc87ce90452","modified":1512565230000},{"_id":"themes/anatole/source/images/logo.png","hash":"a15be4b9393e60d2e288f368681e4a151707c04e","modified":1512934707000},{"_id":"themes/anatole/source/images/logo@2x.png","hash":"a15be4b9393e60d2e288f368681e4a151707c04e","modified":1512934707000},{"_id":"themes/anatole/source/images/logo@2x-old.png","hash":"49c3fa97724abf53861bf11356ea9ba5bcb11576","modified":1512565230000},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1512565230000},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.svg","hash":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1512565230000},{"_id":"themes/anatole/source/js/jquery.js","hash":"bfc05b695dfa4f23e11d04b84993585da7a764bf","modified":1512565230000},{"_id":"source/.DS_Store","hash":"cc22718af932f98d8e951266b0f935f93b17e913","modified":1513101241000},{"_id":"source/images/favicon-32x32.png","hash":"3c10507131119ab08658bd239be6e3634666f954","modified":1512942466000},{"_id":"source/images/side.jpg","hash":"5c63f3b4e0af98f3bce1c22a446650bc135ee185","modified":1513101570000}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2017-12-12T17:16:50.000Z","_content":"\nOlá!\n\nMeu nome é Luiz Adolphs.  Sou desenvolvedor de software desde 2006. \n\nSempre me considerei um generalista, já sujando a mão com diversas linguagens e paradigmas e arquiteturas!\n\nDesenvolvimento é para mim mais que uma profissão, é o exercício de trazer do nada uma criação, o que me gera imensa satisfação!\n\nPor isso permaneço num estado constante de aprendizado por novas tecnologias, arquiteturas, padrões e tudo o que engloba a arte de desenvolver software.\n\nE muito disso vou disseminar neste blog. Espero que você goste :).\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-12-12 17:16:50\n---\n\nOlá!\n\nMeu nome é Luiz Adolphs.  Sou desenvolvedor de software desde 2006. \n\nSempre me considerei um generalista, já sujando a mão com diversas linguagens e paradigmas e arquiteturas!\n\nDesenvolvimento é para mim mais que uma profissão, é o exercício de trazer do nada uma criação, o que me gera imensa satisfação!\n\nPor isso permaneço num estado constante de aprendizado por novas tecnologias, arquiteturas, padrões e tudo o que engloba a arte de desenvolver software.\n\nE muito disso vou disseminar neste blog. Espero que você goste :).\n","updated":"2017-12-12T17:24:57.000Z","path":"about/index.html","_id":"cjb3w3a7s00020rlmex0pq6k1","comments":1,"layout":"page","content":"<p>Olá!</p>\n<p>Meu nome é Luiz Adolphs.  Sou desenvolvedor de software desde 2006. </p>\n<p>Sempre me considerei um generalista, já sujando a mão com diversas linguagens e paradigmas e arquiteturas!</p>\n<p>Desenvolvimento é para mim mais que uma profissão, é o exercício de trazer do nada uma criação, o que me gera imensa satisfação!</p>\n<p>Por isso permaneço num estado constante de aprendizado por novas tecnologias, arquiteturas, padrões e tudo o que engloba a arte de desenvolver software.</p>\n<p>E muito disso vou disseminar neste blog. Espero que você goste :).</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Olá!</p>\n<p>Meu nome é Luiz Adolphs.  Sou desenvolvedor de software desde 2006. </p>\n<p>Sempre me considerei um generalista, já sujando a mão com diversas linguagens e paradigmas e arquiteturas!</p>\n<p>Desenvolvimento é para mim mais que uma profissão, é o exercício de trazer do nada uma criação, o que me gera imensa satisfação!</p>\n<p>Por isso permaneço num estado constante de aprendizado por novas tecnologias, arquiteturas, padrões e tudo o que engloba a arte de desenvolver software.</p>\n<p>E muito disso vou disseminar neste blog. Espero que você goste :).</p>\n"}],"Post":[{"title":"Primeiro Post","date":"2017-12-08T19:12:39.000Z","_content":"\nEste é o primeiro post do meu blog pessoal. Há tempos queria lançar um blog para expor algumas idéias e \"legalzises\" sobre desenvolvimento de software.\n\nSendo assim, aproveitei a estrutura do GitHub Pages para publicar o meu blog. Construí este blog em cima da plataforma [Hexo](https://hexo.io) com o template [Hexo Theme Anatole](https://github.com/Ben02/hexo-theme-Anatole/wiki) (uma hora vou postar aqui o processo que utilizei para construir e publicar o blog) e vou aperfeiçoando-o a medida que o tempo passar. O código fonte deste blog se encontra [aqui](https://github.com/LuizAdolphs/blog). Espero que você goste de ler este conteúdo assim como eu gosto de escrever-lo!","source":"_posts/Primeiro-Post.md","raw":"---\ntitle: Primeiro Post\ndate: 2017-12-08 19:12:39\ntags:\n---\n\nEste é o primeiro post do meu blog pessoal. Há tempos queria lançar um blog para expor algumas idéias e \"legalzises\" sobre desenvolvimento de software.\n\nSendo assim, aproveitei a estrutura do GitHub Pages para publicar o meu blog. Construí este blog em cima da plataforma [Hexo](https://hexo.io) com o template [Hexo Theme Anatole](https://github.com/Ben02/hexo-theme-Anatole/wiki) (uma hora vou postar aqui o processo que utilizei para construir e publicar o blog) e vou aperfeiçoando-o a medida que o tempo passar. O código fonte deste blog se encontra [aqui](https://github.com/LuizAdolphs/blog). Espero que você goste de ler este conteúdo assim como eu gosto de escrever-lo!","slug":"Primeiro-Post","published":1,"updated":"2017-12-10T18:08:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb3w3a7l00000rlmcobwuuxv","content":"<p>Este é o primeiro post do meu blog pessoal. Há tempos queria lançar um blog para expor algumas idéias e “legalzises” sobre desenvolvimento de software.</p>\n<p>Sendo assim, aproveitei a estrutura do GitHub Pages para publicar o meu blog. Construí este blog em cima da plataforma <a href=\"https://hexo.io\" target=\"_blank\" rel=\"noopener\">Hexo</a> com o template <a href=\"https://github.com/Ben02/hexo-theme-Anatole/wiki\" target=\"_blank\" rel=\"noopener\">Hexo Theme Anatole</a> (uma hora vou postar aqui o processo que utilizei para construir e publicar o blog) e vou aperfeiçoando-o a medida que o tempo passar. O código fonte deste blog se encontra <a href=\"https://github.com/LuizAdolphs/blog\" target=\"_blank\" rel=\"noopener\">aqui</a>. Espero que você goste de ler este conteúdo assim como eu gosto de escrever-lo!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Este é o primeiro post do meu blog pessoal. Há tempos queria lançar um blog para expor algumas idéias e “legalzises” sobre desenvolvimento de software.</p>\n<p>Sendo assim, aproveitei a estrutura do GitHub Pages para publicar o meu blog. Construí este blog em cima da plataforma <a href=\"https://hexo.io\" target=\"_blank\" rel=\"noopener\">Hexo</a> com o template <a href=\"https://github.com/Ben02/hexo-theme-Anatole/wiki\" target=\"_blank\" rel=\"noopener\">Hexo Theme Anatole</a> (uma hora vou postar aqui o processo que utilizei para construir e publicar o blog) e vou aperfeiçoando-o a medida que o tempo passar. O código fonte deste blog se encontra <a href=\"https://github.com/LuizAdolphs/blog\" target=\"_blank\" rel=\"noopener\">aqui</a>. Espero que você goste de ler este conteúdo assim como eu gosto de escrever-lo!</p>\n"},{"title":"Brincando com coleções reativas em c#","date":"2017-12-12T18:16:50.000Z","_content":"\nOlá pessoal!\n\nEsses dias estava desenvolvendo uns exercícios em C#, até que em um deles notei um comportamento interessante de IEnumerable e IQueryable. Observe o seguinte código:\n\n```csharp\nusing System;\nusing System.Linq;\nusing System.Collections;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IEnumerable collection = Enumerable.Range(0,10);\n\n            foreach (int item in collection)\n            {\n                Console.WriteLine(item);\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n```\n\nE se executarmos no terminal, a seguinte resposta é gerada:\n\n```bash\nroot@1083f7cca7e3:/app# dotnet run\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\nBom, a resposta gerada era o que esperávamos... Mas o que acontece se trocarmos o `IEnumerable` por `IQueryable`?\n\n```csharp\nusing System;\nusing System.Linq;\nusing System.Collections;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IEnumerable collection = Enumerable.Range(0,10).Select(x => x);\n\n            foreach (int item in collection)\n            {\n                Console.WriteLine(item);\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n```\n\n```bash\nroot@1083f7cca7e3:/app# dotnet run\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\nBasicamente a mesma coisa. Vamos agora colocar uma \ninteração do usuário na expressão:\n\n```bash\nroot@1083f7cca7e3:/app# dotnet run\n\n\n0\n\n1\n\n2\n\n\n```\n\nAlgo interessante acontece... Eu normalmente esperaria pressionar 10x o Enter para então depois o `foreach` printar os números um por linha como nos testes anteriores. \n\nMas não é o que ocorre… A cada interação do `foreach`, a instrução de dentro do `Select` (isso é, o `Console.Readline()`) é executada… Isso acontece porque `Enumerables` (por consequência, `IQueriables`) só executam as expressões quando solicitadas através do `yield`. \n\nUm outro exemplo do que está acontecendo. Observa o seguinte código:\n\n```csharp\n\nusing System;\nusing System.Linq;\nusing System.Collections;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IEnumerable collection = Enumerable\n                .Range(0,10)\n                .Select(x => \n                {\n                    Console.WriteLine($\"---------------------------Executando de dentro do Select da data { DateTime.Now.ToLongTimeString()}\");\n\n                    return x;\n                });\n\n            foreach (int item in collection)\n            {\n                Console.WriteLine($\"Executando de fora do Select { DateTime.Now.ToLongTimeString()}\");\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n\n```\n\nE o resultado:\n\n```bash\n\nroot@1083f7cca7e3:/app# dotnet run\n---------------------------Executando de dentro do Select da data 15:00:12\nExecutando de fora do Select 15:00:13\n---------------------------Executando de dentro do Select da data 15:00:13\nExecutando de fora do Select 15:00:14\n---------------------------Executando de dentro do Select da data 15:00:14\nExecutando de fora do Select 15:00:15\n---------------------------Executando de dentro do Select da data 15:00:15\nExecutando de fora do Select 15:00:16\n---------------------------Executando de dentro do Select da data 15:00:16\nExecutando de fora do Select 15:00:17\n---------------------------Executando de dentro do Select da data 15:00:17\nExecutando de fora do Select 15:00:18\n---------------------------Executando de dentro do Select da data 15:00:18\nExecutando de fora do Select 15:00:19\n---------------------------Executando de dentro do Select da data 15:00:19\nExecutando de fora do Select 15:00:20\n---------------------------Executando de dentro do Select da data 15:00:20\nExecutando de fora do Select 15:00:21\n---------------------------Executando de dentro do Select da data 15:00:21\nExecutando de fora do Select 15:00:22\n\n```\n\nEste resultado nos indica que, a cada interação, o método interno do `Select` é executado.\n\nEste comportamento nos dá diversas vantagens em termos de processamento. Se o método interno, por exemplo, fosse uma chamada um pouco mais pesada em termos de recursos computacionais, ela seria executada sob necessidade. Se por ventura o loop fosse parado no meio, processamento desnecessário seria evitado.\n\nCaso fosse preciso executar todo o método `Select` antes de percorrer-lo, basta apenas forçar a interação dele com métodos de transformação, como por exemplo o `.ToList()`:\n\n\n```csharp\n\nusing System;\nusing System.Linq;\nusing System.Collections;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IEnumerable collection = Enumerable\n                .Range(0,10)\n                .Select(x => \n                {\n                    Console.WriteLine(\"---------------------------Executando de dentro do Select\");\n\n                    return x;\n                })\n                .ToList();\n\n            foreach (int item in collection)\n            {\n                Console.WriteLine(\"Executando de fora do Select\");\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n\n```\n\nE o resultado vira:\n\n```bash\n\nroot@1083f7cca7e3:/app# dotnet run\n---------------------------Executando de dentro do Select da data 15:01:21\n---------------------------Executando de dentro do Select da data 15:01:22\n---------------------------Executando de dentro do Select da data 15:01:23\n---------------------------Executando de dentro do Select da data 15:01:24\n---------------------------Executando de dentro do Select da data 15:01:25\n---------------------------Executando de dentro do Select da data 15:01:26\n---------------------------Executando de dentro do Select da data 15:01:27\n---------------------------Executando de dentro do Select da data 15:01:28\n---------------------------Executando de dentro do Select da data 15:01:29\n---------------------------Executando de dentro do Select da data 15:01:30\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\n\n```\n\nPodemos perceber que o tempo total entre as duas execuções é basicamente o mesmo. Mas o output para o console é bem diferente.\n\nEsta é a implementação do codigo fonte do método `.Select` dentro de [`System.Linq`](https://github.com/dotnet/corefx/blob/master/src/System.Linq/src/System/Linq/Select.cs). É possível observar a utilizaçãp do `yield return` que indica, basicamente, que aquele ponto é o ponto de retorno para o interação corrente, isso é, o retorno é executado quantas vezes for necessário de acordo com a quantidade da coleção.\n\n```csharp\n\nprivate static IEnumerable<TResult> SelectIterator<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> selector)\n{\n    int index = -1;\n    foreach (TSource element in source)\n    {\n        checked\n        {\n            index++;\n        }\n\n        yield return selector(element, index);\n    }\n}\n\n```\n\n### Mas por que podemos dizer que este código é Reativo?\n\nQuando tratamos de consultar uma coleção, que é nosso exemplo, podemos ter dois comportamentos possíveis: Reativo e Pró-ativo.\n\nO pró-ativo é o comportamento que calcula os resultados possíveis antes mesmo de serem requisitados. É o que aconteceu no nosso ultimo exemplo quando adicionamos o `.ToList()`. Toda a coleção foi iterada e calculada de modo que no `foreach` subsequente apenas o `Consolte.Write` de dentro do foreach foi executado.\n\nJá a abordagem Reativa vai executando cada item da coleção e obtendo seu resultado à cada interação. Podemos dizer ao iterar há uma \"Reação\" interna de dentro da coleção que executa a posição corrente (e obtém seu resultado na hora, não anteriormente).\n\n### Um exemplo mais complexo\n\nPara este exemplo estou usando a API do [Pokémon](https://www.pokeapi.co) por ser free e não necessitar autenticação. Vamos implementar a necessidade de listar os 10 primeiros pokémons, sendo que a listagem deve cessar assim que encontrar o primeiro pokémon do tipo \"fogo\". Primeiro, vamos usar a abordagem pró-ativa:\n\n```csharp\nusing static Newtonsoft.Json.JsonConvert;\nusing System;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Diagnostics;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var stopWatch = new Stopwatch();\n\n            stopWatch.Start();\n\n            using(var client = new HttpClient())\n            {\n                client.DefaultRequestHeaders.Accept.Clear();\n                client.DefaultRequestHeaders.Accept.Add(\n                    new MediaTypeWithQualityHeaderValue(\"application/json\"));\n\n                IEnumerable<Pokemon> pokemons = Enumerable\n                .Range(1,11)\n                .Select(x => \n                {\n                    var result = client.GetAsync($\"http://pokeapi.co/api/v2/pokemon/{x}\").Result; \n\n                    return DeserializeObject<Pokemon>(result.Content.ReadAsStringAsync().Result);\n                })\n                .ToList();   \n\n                foreach(var pokemon in pokemons)\n                {\n                    Console.WriteLine(pokemon.Name);\n\n                    if(pokemon.Types.Any(x => x.Type.Name.ToLower() == \"fire\"))\n                        break;\n                }\n\n            }\n\n            stopWatch.Stop();\n\n            Console.WriteLine($\"Tempo de execução: {stopWatch.Elapsed.Seconds} segundos\");\n        }\n    }\n    public class Pokemon\n    {\n        public string Name { get; set; }\n        public IList<PokemonTypeSlot> Types { get; set; }\n\n        public class PokemonTypeSlot\n        {\n            public int Slot { get; set; }\n            public PokemonType Type { get; set; }\n            public class PokemonType {\n                public string Name { get; set; }\n            }\n        }\n    }\n}\n```\n\nResultado:\n\n```bash\nroot@1083f7cca7e3:/app# dotnet run\nbulbasaur\nivysaur\nvenusaur\ncharmander\nTempo de execução: 36 segundos\n```\n\nAgora, vamos apenas tirar o `.ToList()` e permitir a chamada à API por interação (mostrarei só o trecho):\n\n```csharp\n...\n                IEnumerable<Pokemon> pokemons = Enumerable\n                .Range(1,11)\n                .Select(x => \n                {\n                    var result = client.GetAsync($\"http://pokeapi.co/api/v2/pokemon/{x}\").Result; \n\n                    return DeserializeObject<Pokemon>(result.Content.ReadAsStringAsync().Result);\n                });   \n\n                foreach(var pokemon in pokemons)\n                {\n                    Console.WriteLine(pokemon.Name);\n\n                    if(pokemon.Types.Any(x => x.Type.Name.ToLower() == \"fire\"))\n                        break;\n                }\n...\n```\n\nO resultando é bem diferente:\n\n```bash\nroot@1083f7cca7e3:/app# dotnet run\nbulbasaur\nivysaur\nvenusaur\ncharmander\nTempo de execução: 10 segundos\n```\n\nVale lembrar que certamente há melhores maneiras de consumir esta API e obter o mesmo resultado, mas desenvolvi assim para explicar melhor o conceito.\n\n### Conclusão\n\nAbordagens Reativas ou Pró-ativas são meios diferentes de se obter resultados numa linha de tempo. É errado perguntar quais das duas é melhor, pois dependendo do contexto é interessante utilizar um ou outro. O importante aqui é saber as diferenças e possibilidades de se trabalhar com ambas.\n\nCaso você queira, deixei meu código [aqui](https://github.com/LuizAdolphs/blog/tree/master/codes/reactiveCollection)","source":"_posts/Brincando-com-colecoes-reativas-em-c.md","raw":"---\ntitle: 'Brincando com coleções reativas em c#'\ndate: 2017-12-12 18:16:50\ntags:\n---\n\nOlá pessoal!\n\nEsses dias estava desenvolvendo uns exercícios em C#, até que em um deles notei um comportamento interessante de IEnumerable e IQueryable. Observe o seguinte código:\n\n```csharp\nusing System;\nusing System.Linq;\nusing System.Collections;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IEnumerable collection = Enumerable.Range(0,10);\n\n            foreach (int item in collection)\n            {\n                Console.WriteLine(item);\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n```\n\nE se executarmos no terminal, a seguinte resposta é gerada:\n\n```bash\nroot@1083f7cca7e3:/app# dotnet run\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\nBom, a resposta gerada era o que esperávamos... Mas o que acontece se trocarmos o `IEnumerable` por `IQueryable`?\n\n```csharp\nusing System;\nusing System.Linq;\nusing System.Collections;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IEnumerable collection = Enumerable.Range(0,10).Select(x => x);\n\n            foreach (int item in collection)\n            {\n                Console.WriteLine(item);\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n```\n\n```bash\nroot@1083f7cca7e3:/app# dotnet run\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\nBasicamente a mesma coisa. Vamos agora colocar uma \ninteração do usuário na expressão:\n\n```bash\nroot@1083f7cca7e3:/app# dotnet run\n\n\n0\n\n1\n\n2\n\n\n```\n\nAlgo interessante acontece... Eu normalmente esperaria pressionar 10x o Enter para então depois o `foreach` printar os números um por linha como nos testes anteriores. \n\nMas não é o que ocorre… A cada interação do `foreach`, a instrução de dentro do `Select` (isso é, o `Console.Readline()`) é executada… Isso acontece porque `Enumerables` (por consequência, `IQueriables`) só executam as expressões quando solicitadas através do `yield`. \n\nUm outro exemplo do que está acontecendo. Observa o seguinte código:\n\n```csharp\n\nusing System;\nusing System.Linq;\nusing System.Collections;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IEnumerable collection = Enumerable\n                .Range(0,10)\n                .Select(x => \n                {\n                    Console.WriteLine($\"---------------------------Executando de dentro do Select da data { DateTime.Now.ToLongTimeString()}\");\n\n                    return x;\n                });\n\n            foreach (int item in collection)\n            {\n                Console.WriteLine($\"Executando de fora do Select { DateTime.Now.ToLongTimeString()}\");\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n\n```\n\nE o resultado:\n\n```bash\n\nroot@1083f7cca7e3:/app# dotnet run\n---------------------------Executando de dentro do Select da data 15:00:12\nExecutando de fora do Select 15:00:13\n---------------------------Executando de dentro do Select da data 15:00:13\nExecutando de fora do Select 15:00:14\n---------------------------Executando de dentro do Select da data 15:00:14\nExecutando de fora do Select 15:00:15\n---------------------------Executando de dentro do Select da data 15:00:15\nExecutando de fora do Select 15:00:16\n---------------------------Executando de dentro do Select da data 15:00:16\nExecutando de fora do Select 15:00:17\n---------------------------Executando de dentro do Select da data 15:00:17\nExecutando de fora do Select 15:00:18\n---------------------------Executando de dentro do Select da data 15:00:18\nExecutando de fora do Select 15:00:19\n---------------------------Executando de dentro do Select da data 15:00:19\nExecutando de fora do Select 15:00:20\n---------------------------Executando de dentro do Select da data 15:00:20\nExecutando de fora do Select 15:00:21\n---------------------------Executando de dentro do Select da data 15:00:21\nExecutando de fora do Select 15:00:22\n\n```\n\nEste resultado nos indica que, a cada interação, o método interno do `Select` é executado.\n\nEste comportamento nos dá diversas vantagens em termos de processamento. Se o método interno, por exemplo, fosse uma chamada um pouco mais pesada em termos de recursos computacionais, ela seria executada sob necessidade. Se por ventura o loop fosse parado no meio, processamento desnecessário seria evitado.\n\nCaso fosse preciso executar todo o método `Select` antes de percorrer-lo, basta apenas forçar a interação dele com métodos de transformação, como por exemplo o `.ToList()`:\n\n\n```csharp\n\nusing System;\nusing System.Linq;\nusing System.Collections;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IEnumerable collection = Enumerable\n                .Range(0,10)\n                .Select(x => \n                {\n                    Console.WriteLine(\"---------------------------Executando de dentro do Select\");\n\n                    return x;\n                })\n                .ToList();\n\n            foreach (int item in collection)\n            {\n                Console.WriteLine(\"Executando de fora do Select\");\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n\n```\n\nE o resultado vira:\n\n```bash\n\nroot@1083f7cca7e3:/app# dotnet run\n---------------------------Executando de dentro do Select da data 15:01:21\n---------------------------Executando de dentro do Select da data 15:01:22\n---------------------------Executando de dentro do Select da data 15:01:23\n---------------------------Executando de dentro do Select da data 15:01:24\n---------------------------Executando de dentro do Select da data 15:01:25\n---------------------------Executando de dentro do Select da data 15:01:26\n---------------------------Executando de dentro do Select da data 15:01:27\n---------------------------Executando de dentro do Select da data 15:01:28\n---------------------------Executando de dentro do Select da data 15:01:29\n---------------------------Executando de dentro do Select da data 15:01:30\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\n\n```\n\nPodemos perceber que o tempo total entre as duas execuções é basicamente o mesmo. Mas o output para o console é bem diferente.\n\nEsta é a implementação do codigo fonte do método `.Select` dentro de [`System.Linq`](https://github.com/dotnet/corefx/blob/master/src/System.Linq/src/System/Linq/Select.cs). É possível observar a utilizaçãp do `yield return` que indica, basicamente, que aquele ponto é o ponto de retorno para o interação corrente, isso é, o retorno é executado quantas vezes for necessário de acordo com a quantidade da coleção.\n\n```csharp\n\nprivate static IEnumerable<TResult> SelectIterator<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> selector)\n{\n    int index = -1;\n    foreach (TSource element in source)\n    {\n        checked\n        {\n            index++;\n        }\n\n        yield return selector(element, index);\n    }\n}\n\n```\n\n### Mas por que podemos dizer que este código é Reativo?\n\nQuando tratamos de consultar uma coleção, que é nosso exemplo, podemos ter dois comportamentos possíveis: Reativo e Pró-ativo.\n\nO pró-ativo é o comportamento que calcula os resultados possíveis antes mesmo de serem requisitados. É o que aconteceu no nosso ultimo exemplo quando adicionamos o `.ToList()`. Toda a coleção foi iterada e calculada de modo que no `foreach` subsequente apenas o `Consolte.Write` de dentro do foreach foi executado.\n\nJá a abordagem Reativa vai executando cada item da coleção e obtendo seu resultado à cada interação. Podemos dizer ao iterar há uma \"Reação\" interna de dentro da coleção que executa a posição corrente (e obtém seu resultado na hora, não anteriormente).\n\n### Um exemplo mais complexo\n\nPara este exemplo estou usando a API do [Pokémon](https://www.pokeapi.co) por ser free e não necessitar autenticação. Vamos implementar a necessidade de listar os 10 primeiros pokémons, sendo que a listagem deve cessar assim que encontrar o primeiro pokémon do tipo \"fogo\". Primeiro, vamos usar a abordagem pró-ativa:\n\n```csharp\nusing static Newtonsoft.Json.JsonConvert;\nusing System;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Diagnostics;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var stopWatch = new Stopwatch();\n\n            stopWatch.Start();\n\n            using(var client = new HttpClient())\n            {\n                client.DefaultRequestHeaders.Accept.Clear();\n                client.DefaultRequestHeaders.Accept.Add(\n                    new MediaTypeWithQualityHeaderValue(\"application/json\"));\n\n                IEnumerable<Pokemon> pokemons = Enumerable\n                .Range(1,11)\n                .Select(x => \n                {\n                    var result = client.GetAsync($\"http://pokeapi.co/api/v2/pokemon/{x}\").Result; \n\n                    return DeserializeObject<Pokemon>(result.Content.ReadAsStringAsync().Result);\n                })\n                .ToList();   \n\n                foreach(var pokemon in pokemons)\n                {\n                    Console.WriteLine(pokemon.Name);\n\n                    if(pokemon.Types.Any(x => x.Type.Name.ToLower() == \"fire\"))\n                        break;\n                }\n\n            }\n\n            stopWatch.Stop();\n\n            Console.WriteLine($\"Tempo de execução: {stopWatch.Elapsed.Seconds} segundos\");\n        }\n    }\n    public class Pokemon\n    {\n        public string Name { get; set; }\n        public IList<PokemonTypeSlot> Types { get; set; }\n\n        public class PokemonTypeSlot\n        {\n            public int Slot { get; set; }\n            public PokemonType Type { get; set; }\n            public class PokemonType {\n                public string Name { get; set; }\n            }\n        }\n    }\n}\n```\n\nResultado:\n\n```bash\nroot@1083f7cca7e3:/app# dotnet run\nbulbasaur\nivysaur\nvenusaur\ncharmander\nTempo de execução: 36 segundos\n```\n\nAgora, vamos apenas tirar o `.ToList()` e permitir a chamada à API por interação (mostrarei só o trecho):\n\n```csharp\n...\n                IEnumerable<Pokemon> pokemons = Enumerable\n                .Range(1,11)\n                .Select(x => \n                {\n                    var result = client.GetAsync($\"http://pokeapi.co/api/v2/pokemon/{x}\").Result; \n\n                    return DeserializeObject<Pokemon>(result.Content.ReadAsStringAsync().Result);\n                });   \n\n                foreach(var pokemon in pokemons)\n                {\n                    Console.WriteLine(pokemon.Name);\n\n                    if(pokemon.Types.Any(x => x.Type.Name.ToLower() == \"fire\"))\n                        break;\n                }\n...\n```\n\nO resultando é bem diferente:\n\n```bash\nroot@1083f7cca7e3:/app# dotnet run\nbulbasaur\nivysaur\nvenusaur\ncharmander\nTempo de execução: 10 segundos\n```\n\nVale lembrar que certamente há melhores maneiras de consumir esta API e obter o mesmo resultado, mas desenvolvi assim para explicar melhor o conceito.\n\n### Conclusão\n\nAbordagens Reativas ou Pró-ativas são meios diferentes de se obter resultados numa linha de tempo. É errado perguntar quais das duas é melhor, pois dependendo do contexto é interessante utilizar um ou outro. O importante aqui é saber as diferenças e possibilidades de se trabalhar com ambas.\n\nCaso você queira, deixei meu código [aqui](https://github.com/LuizAdolphs/blog/tree/master/codes/reactiveCollection)","slug":"Brincando-com-colecoes-reativas-em-c","published":1,"updated":"2017-12-12T17:25:23.000Z","_id":"cjb3w3a7o00010rlm6ht6u00c","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Olá pessoal!</p>\n<p>Esses dias estava desenvolvendo uns exercícios em C#, até que em um deles notei um comportamento interessante de IEnumerable e IQueryable. Observe o seguinte código:</p>\n<pre><code class=\"csharp\">using System;\nusing System.Linq;\nusing System.Collections;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IEnumerable collection = Enumerable.Range(0,10);\n\n            foreach (int item in collection)\n            {\n                Console.WriteLine(item);\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n</code></pre>\n<p>E se executarmos no terminal, a seguinte resposta é gerada:</p>\n<pre><code class=\"bash\">root@1083f7cca7e3:/app# dotnet run\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre>\n<p>Bom, a resposta gerada era o que esperávamos… Mas o que acontece se trocarmos o <code>IEnumerable</code> por <code>IQueryable</code>?</p>\n<pre><code class=\"csharp\">using System;\nusing System.Linq;\nusing System.Collections;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IEnumerable collection = Enumerable.Range(0,10).Select(x =&gt; x);\n\n            foreach (int item in collection)\n            {\n                Console.WriteLine(item);\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"bash\">root@1083f7cca7e3:/app# dotnet run\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre>\n<p>Basicamente a mesma coisa. Vamos agora colocar uma<br>interação do usuário na expressão:</p>\n<pre><code class=\"bash\">root@1083f7cca7e3:/app# dotnet run\n\n\n0\n\n1\n\n2\n</code></pre>\n<p>Algo interessante acontece… Eu normalmente esperaria pressionar 10x o Enter para então depois o <code>foreach</code> printar os números um por linha como nos testes anteriores. </p>\n<p>Mas não é o que ocorre… A cada interação do <code>foreach</code>, a instrução de dentro do <code>Select</code> (isso é, o <code>Console.Readline()</code>) é executada… Isso acontece porque <code>Enumerables</code> (por consequência, <code>IQueriables</code>) só executam as expressões quando solicitadas através do <code>yield</code>. </p>\n<p>Um outro exemplo do que está acontecendo. Observa o seguinte código:</p>\n<pre><code class=\"csharp\">\nusing System;\nusing System.Linq;\nusing System.Collections;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IEnumerable collection = Enumerable\n                .Range(0,10)\n                .Select(x =&gt; \n                {\n                    Console.WriteLine($&quot;---------------------------Executando de dentro do Select da data { DateTime.Now.ToLongTimeString()}&quot;);\n\n                    return x;\n                });\n\n            foreach (int item in collection)\n            {\n                Console.WriteLine($&quot;Executando de fora do Select { DateTime.Now.ToLongTimeString()}&quot;);\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n</code></pre>\n<p>E o resultado:</p>\n<pre><code class=\"bash\">\nroot@1083f7cca7e3:/app# dotnet run\n---------------------------Executando de dentro do Select da data 15:00:12\nExecutando de fora do Select 15:00:13\n---------------------------Executando de dentro do Select da data 15:00:13\nExecutando de fora do Select 15:00:14\n---------------------------Executando de dentro do Select da data 15:00:14\nExecutando de fora do Select 15:00:15\n---------------------------Executando de dentro do Select da data 15:00:15\nExecutando de fora do Select 15:00:16\n---------------------------Executando de dentro do Select da data 15:00:16\nExecutando de fora do Select 15:00:17\n---------------------------Executando de dentro do Select da data 15:00:17\nExecutando de fora do Select 15:00:18\n---------------------------Executando de dentro do Select da data 15:00:18\nExecutando de fora do Select 15:00:19\n---------------------------Executando de dentro do Select da data 15:00:19\nExecutando de fora do Select 15:00:20\n---------------------------Executando de dentro do Select da data 15:00:20\nExecutando de fora do Select 15:00:21\n---------------------------Executando de dentro do Select da data 15:00:21\nExecutando de fora do Select 15:00:22\n</code></pre>\n<p>Este resultado nos indica que, a cada interação, o método interno do <code>Select</code> é executado.</p>\n<p>Este comportamento nos dá diversas vantagens em termos de processamento. Se o método interno, por exemplo, fosse uma chamada um pouco mais pesada em termos de recursos computacionais, ela seria executada sob necessidade. Se por ventura o loop fosse parado no meio, processamento desnecessário seria evitado.</p>\n<p>Caso fosse preciso executar todo o método <code>Select</code> antes de percorrer-lo, basta apenas forçar a interação dele com métodos de transformação, como por exemplo o <code>.ToList()</code>:</p>\n<pre><code class=\"csharp\">\nusing System;\nusing System.Linq;\nusing System.Collections;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IEnumerable collection = Enumerable\n                .Range(0,10)\n                .Select(x =&gt; \n                {\n                    Console.WriteLine(&quot;---------------------------Executando de dentro do Select&quot;);\n\n                    return x;\n                })\n                .ToList();\n\n            foreach (int item in collection)\n            {\n                Console.WriteLine(&quot;Executando de fora do Select&quot;);\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n</code></pre>\n<p>E o resultado vira:</p>\n<pre><code class=\"bash\">\nroot@1083f7cca7e3:/app# dotnet run\n---------------------------Executando de dentro do Select da data 15:01:21\n---------------------------Executando de dentro do Select da data 15:01:22\n---------------------------Executando de dentro do Select da data 15:01:23\n---------------------------Executando de dentro do Select da data 15:01:24\n---------------------------Executando de dentro do Select da data 15:01:25\n---------------------------Executando de dentro do Select da data 15:01:26\n---------------------------Executando de dentro do Select da data 15:01:27\n---------------------------Executando de dentro do Select da data 15:01:28\n---------------------------Executando de dentro do Select da data 15:01:29\n---------------------------Executando de dentro do Select da data 15:01:30\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\n</code></pre>\n<p>Podemos perceber que o tempo total entre as duas execuções é basicamente o mesmo. Mas o output para o console é bem diferente.</p>\n<p>Esta é a implementação do codigo fonte do método <code>.Select</code> dentro de <a href=\"https://github.com/dotnet/corefx/blob/master/src/System.Linq/src/System/Linq/Select.cs\" target=\"_blank\" rel=\"noopener\"><code>System.Linq</code></a>. É possível observar a utilizaçãp do <code>yield return</code> que indica, basicamente, que aquele ponto é o ponto de retorno para o interação corrente, isso é, o retorno é executado quantas vezes for necessário de acordo com a quantidade da coleção.</p>\n<pre><code class=\"csharp\">\nprivate static IEnumerable&lt;TResult&gt; SelectIterator&lt;TSource, TResult&gt;(IEnumerable&lt;TSource&gt; source, Func&lt;TSource, int, TResult&gt; selector)\n{\n    int index = -1;\n    foreach (TSource element in source)\n    {\n        checked\n        {\n            index++;\n        }\n\n        yield return selector(element, index);\n    }\n}\n</code></pre>\n<h3 id=\"Mas-por-que-podemos-dizer-que-este-codigo-e-Reativo\"><a href=\"#Mas-por-que-podemos-dizer-que-este-codigo-e-Reativo\" class=\"headerlink\" title=\"Mas por que podemos dizer que este código é Reativo?\"></a>Mas por que podemos dizer que este código é Reativo?</h3><p>Quando tratamos de consultar uma coleção, que é nosso exemplo, podemos ter dois comportamentos possíveis: Reativo e Pró-ativo.</p>\n<p>O pró-ativo é o comportamento que calcula os resultados possíveis antes mesmo de serem requisitados. É o que aconteceu no nosso ultimo exemplo quando adicionamos o <code>.ToList()</code>. Toda a coleção foi iterada e calculada de modo que no <code>foreach</code> subsequente apenas o <code>Consolte.Write</code> de dentro do foreach foi executado.</p>\n<p>Já a abordagem Reativa vai executando cada item da coleção e obtendo seu resultado à cada interação. Podemos dizer ao iterar há uma “Reação” interna de dentro da coleção que executa a posição corrente (e obtém seu resultado na hora, não anteriormente).</p>\n<h3 id=\"Um-exemplo-mais-complexo\"><a href=\"#Um-exemplo-mais-complexo\" class=\"headerlink\" title=\"Um exemplo mais complexo\"></a>Um exemplo mais complexo</h3><p>Para este exemplo estou usando a API do <a href=\"https://www.pokeapi.co\" target=\"_blank\" rel=\"noopener\">Pokémon</a> por ser free e não necessitar autenticação. Vamos implementar a necessidade de listar os 10 primeiros pokémons, sendo que a listagem deve cessar assim que encontrar o primeiro pokémon do tipo “fogo”. Primeiro, vamos usar a abordagem pró-ativa:</p>\n<pre><code class=\"csharp\">using static Newtonsoft.Json.JsonConvert;\nusing System;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Diagnostics;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var stopWatch = new Stopwatch();\n\n            stopWatch.Start();\n\n            using(var client = new HttpClient())\n            {\n                client.DefaultRequestHeaders.Accept.Clear();\n                client.DefaultRequestHeaders.Accept.Add(\n                    new MediaTypeWithQualityHeaderValue(&quot;application/json&quot;));\n\n                IEnumerable&lt;Pokemon&gt; pokemons = Enumerable\n                .Range(1,11)\n                .Select(x =&gt; \n                {\n                    var result = client.GetAsync($&quot;http://pokeapi.co/api/v2/pokemon/{x}&quot;).Result; \n\n                    return DeserializeObject&lt;Pokemon&gt;(result.Content.ReadAsStringAsync().Result);\n                })\n                .ToList();   \n\n                foreach(var pokemon in pokemons)\n                {\n                    Console.WriteLine(pokemon.Name);\n\n                    if(pokemon.Types.Any(x =&gt; x.Type.Name.ToLower() == &quot;fire&quot;))\n                        break;\n                }\n\n            }\n\n            stopWatch.Stop();\n\n            Console.WriteLine($&quot;Tempo de execução: {stopWatch.Elapsed.Seconds} segundos&quot;);\n        }\n    }\n    public class Pokemon\n    {\n        public string Name { get; set; }\n        public IList&lt;PokemonTypeSlot&gt; Types { get; set; }\n\n        public class PokemonTypeSlot\n        {\n            public int Slot { get; set; }\n            public PokemonType Type { get; set; }\n            public class PokemonType {\n                public string Name { get; set; }\n            }\n        }\n    }\n}\n</code></pre>\n<p>Resultado:</p>\n<pre><code class=\"bash\">root@1083f7cca7e3:/app# dotnet run\nbulbasaur\nivysaur\nvenusaur\ncharmander\nTempo de execução: 36 segundos\n</code></pre>\n<p>Agora, vamos apenas tirar o <code>.ToList()</code> e permitir a chamada à API por interação (mostrarei só o trecho):</p>\n<pre><code class=\"csharp\">...\n                IEnumerable&lt;Pokemon&gt; pokemons = Enumerable\n                .Range(1,11)\n                .Select(x =&gt; \n                {\n                    var result = client.GetAsync($&quot;http://pokeapi.co/api/v2/pokemon/{x}&quot;).Result; \n\n                    return DeserializeObject&lt;Pokemon&gt;(result.Content.ReadAsStringAsync().Result);\n                });   \n\n                foreach(var pokemon in pokemons)\n                {\n                    Console.WriteLine(pokemon.Name);\n\n                    if(pokemon.Types.Any(x =&gt; x.Type.Name.ToLower() == &quot;fire&quot;))\n                        break;\n                }\n...\n</code></pre>\n<p>O resultando é bem diferente:</p>\n<pre><code class=\"bash\">root@1083f7cca7e3:/app# dotnet run\nbulbasaur\nivysaur\nvenusaur\ncharmander\nTempo de execução: 10 segundos\n</code></pre>\n<p>Vale lembrar que certamente há melhores maneiras de consumir esta API e obter o mesmo resultado, mas desenvolvi assim para explicar melhor o conceito.</p>\n<h3 id=\"Conclusao\"><a href=\"#Conclusao\" class=\"headerlink\" title=\"Conclusão\"></a>Conclusão</h3><p>Abordagens Reativas ou Pró-ativas são meios diferentes de se obter resultados numa linha de tempo. É errado perguntar quais das duas é melhor, pois dependendo do contexto é interessante utilizar um ou outro. O importante aqui é saber as diferenças e possibilidades de se trabalhar com ambas.</p>\n<p>Caso você queira, deixei meu código <a href=\"https://github.com/LuizAdolphs/blog/tree/master/codes/reactiveCollection\" target=\"_blank\" rel=\"noopener\">aqui</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Olá pessoal!</p>\n<p>Esses dias estava desenvolvendo uns exercícios em C#, até que em um deles notei um comportamento interessante de IEnumerable e IQueryable. Observe o seguinte código:</p>\n<pre><code class=\"csharp\">using System;\nusing System.Linq;\nusing System.Collections;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IEnumerable collection = Enumerable.Range(0,10);\n\n            foreach (int item in collection)\n            {\n                Console.WriteLine(item);\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n</code></pre>\n<p>E se executarmos no terminal, a seguinte resposta é gerada:</p>\n<pre><code class=\"bash\">root@1083f7cca7e3:/app# dotnet run\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre>\n<p>Bom, a resposta gerada era o que esperávamos… Mas o que acontece se trocarmos o <code>IEnumerable</code> por <code>IQueryable</code>?</p>\n<pre><code class=\"csharp\">using System;\nusing System.Linq;\nusing System.Collections;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IEnumerable collection = Enumerable.Range(0,10).Select(x =&gt; x);\n\n            foreach (int item in collection)\n            {\n                Console.WriteLine(item);\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"bash\">root@1083f7cca7e3:/app# dotnet run\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre>\n<p>Basicamente a mesma coisa. Vamos agora colocar uma<br>interação do usuário na expressão:</p>\n<pre><code class=\"bash\">root@1083f7cca7e3:/app# dotnet run\n\n\n0\n\n1\n\n2\n</code></pre>\n<p>Algo interessante acontece… Eu normalmente esperaria pressionar 10x o Enter para então depois o <code>foreach</code> printar os números um por linha como nos testes anteriores. </p>\n<p>Mas não é o que ocorre… A cada interação do <code>foreach</code>, a instrução de dentro do <code>Select</code> (isso é, o <code>Console.Readline()</code>) é executada… Isso acontece porque <code>Enumerables</code> (por consequência, <code>IQueriables</code>) só executam as expressões quando solicitadas através do <code>yield</code>. </p>\n<p>Um outro exemplo do que está acontecendo. Observa o seguinte código:</p>\n<pre><code class=\"csharp\">\nusing System;\nusing System.Linq;\nusing System.Collections;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IEnumerable collection = Enumerable\n                .Range(0,10)\n                .Select(x =&gt; \n                {\n                    Console.WriteLine($&quot;---------------------------Executando de dentro do Select da data { DateTime.Now.ToLongTimeString()}&quot;);\n\n                    return x;\n                });\n\n            foreach (int item in collection)\n            {\n                Console.WriteLine($&quot;Executando de fora do Select { DateTime.Now.ToLongTimeString()}&quot;);\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n</code></pre>\n<p>E o resultado:</p>\n<pre><code class=\"bash\">\nroot@1083f7cca7e3:/app# dotnet run\n---------------------------Executando de dentro do Select da data 15:00:12\nExecutando de fora do Select 15:00:13\n---------------------------Executando de dentro do Select da data 15:00:13\nExecutando de fora do Select 15:00:14\n---------------------------Executando de dentro do Select da data 15:00:14\nExecutando de fora do Select 15:00:15\n---------------------------Executando de dentro do Select da data 15:00:15\nExecutando de fora do Select 15:00:16\n---------------------------Executando de dentro do Select da data 15:00:16\nExecutando de fora do Select 15:00:17\n---------------------------Executando de dentro do Select da data 15:00:17\nExecutando de fora do Select 15:00:18\n---------------------------Executando de dentro do Select da data 15:00:18\nExecutando de fora do Select 15:00:19\n---------------------------Executando de dentro do Select da data 15:00:19\nExecutando de fora do Select 15:00:20\n---------------------------Executando de dentro do Select da data 15:00:20\nExecutando de fora do Select 15:00:21\n---------------------------Executando de dentro do Select da data 15:00:21\nExecutando de fora do Select 15:00:22\n</code></pre>\n<p>Este resultado nos indica que, a cada interação, o método interno do <code>Select</code> é executado.</p>\n<p>Este comportamento nos dá diversas vantagens em termos de processamento. Se o método interno, por exemplo, fosse uma chamada um pouco mais pesada em termos de recursos computacionais, ela seria executada sob necessidade. Se por ventura o loop fosse parado no meio, processamento desnecessário seria evitado.</p>\n<p>Caso fosse preciso executar todo o método <code>Select</code> antes de percorrer-lo, basta apenas forçar a interação dele com métodos de transformação, como por exemplo o <code>.ToList()</code>:</p>\n<pre><code class=\"csharp\">\nusing System;\nusing System.Linq;\nusing System.Collections;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IEnumerable collection = Enumerable\n                .Range(0,10)\n                .Select(x =&gt; \n                {\n                    Console.WriteLine(&quot;---------------------------Executando de dentro do Select&quot;);\n\n                    return x;\n                })\n                .ToList();\n\n            foreach (int item in collection)\n            {\n                Console.WriteLine(&quot;Executando de fora do Select&quot;);\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n</code></pre>\n<p>E o resultado vira:</p>\n<pre><code class=\"bash\">\nroot@1083f7cca7e3:/app# dotnet run\n---------------------------Executando de dentro do Select da data 15:01:21\n---------------------------Executando de dentro do Select da data 15:01:22\n---------------------------Executando de dentro do Select da data 15:01:23\n---------------------------Executando de dentro do Select da data 15:01:24\n---------------------------Executando de dentro do Select da data 15:01:25\n---------------------------Executando de dentro do Select da data 15:01:26\n---------------------------Executando de dentro do Select da data 15:01:27\n---------------------------Executando de dentro do Select da data 15:01:28\n---------------------------Executando de dentro do Select da data 15:01:29\n---------------------------Executando de dentro do Select da data 15:01:30\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\nExecutando de fora do Select 15:01:31\n</code></pre>\n<p>Podemos perceber que o tempo total entre as duas execuções é basicamente o mesmo. Mas o output para o console é bem diferente.</p>\n<p>Esta é a implementação do codigo fonte do método <code>.Select</code> dentro de <a href=\"https://github.com/dotnet/corefx/blob/master/src/System.Linq/src/System/Linq/Select.cs\" target=\"_blank\" rel=\"noopener\"><code>System.Linq</code></a>. É possível observar a utilizaçãp do <code>yield return</code> que indica, basicamente, que aquele ponto é o ponto de retorno para o interação corrente, isso é, o retorno é executado quantas vezes for necessário de acordo com a quantidade da coleção.</p>\n<pre><code class=\"csharp\">\nprivate static IEnumerable&lt;TResult&gt; SelectIterator&lt;TSource, TResult&gt;(IEnumerable&lt;TSource&gt; source, Func&lt;TSource, int, TResult&gt; selector)\n{\n    int index = -1;\n    foreach (TSource element in source)\n    {\n        checked\n        {\n            index++;\n        }\n\n        yield return selector(element, index);\n    }\n}\n</code></pre>\n<h3 id=\"Mas-por-que-podemos-dizer-que-este-codigo-e-Reativo\"><a href=\"#Mas-por-que-podemos-dizer-que-este-codigo-e-Reativo\" class=\"headerlink\" title=\"Mas por que podemos dizer que este código é Reativo?\"></a>Mas por que podemos dizer que este código é Reativo?</h3><p>Quando tratamos de consultar uma coleção, que é nosso exemplo, podemos ter dois comportamentos possíveis: Reativo e Pró-ativo.</p>\n<p>O pró-ativo é o comportamento que calcula os resultados possíveis antes mesmo de serem requisitados. É o que aconteceu no nosso ultimo exemplo quando adicionamos o <code>.ToList()</code>. Toda a coleção foi iterada e calculada de modo que no <code>foreach</code> subsequente apenas o <code>Consolte.Write</code> de dentro do foreach foi executado.</p>\n<p>Já a abordagem Reativa vai executando cada item da coleção e obtendo seu resultado à cada interação. Podemos dizer ao iterar há uma “Reação” interna de dentro da coleção que executa a posição corrente (e obtém seu resultado na hora, não anteriormente).</p>\n<h3 id=\"Um-exemplo-mais-complexo\"><a href=\"#Um-exemplo-mais-complexo\" class=\"headerlink\" title=\"Um exemplo mais complexo\"></a>Um exemplo mais complexo</h3><p>Para este exemplo estou usando a API do <a href=\"https://www.pokeapi.co\" target=\"_blank\" rel=\"noopener\">Pokémon</a> por ser free e não necessitar autenticação. Vamos implementar a necessidade de listar os 10 primeiros pokémons, sendo que a listagem deve cessar assim que encontrar o primeiro pokémon do tipo “fogo”. Primeiro, vamos usar a abordagem pró-ativa:</p>\n<pre><code class=\"csharp\">using static Newtonsoft.Json.JsonConvert;\nusing System;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Diagnostics;\n\nnamespace reactiveCollection\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var stopWatch = new Stopwatch();\n\n            stopWatch.Start();\n\n            using(var client = new HttpClient())\n            {\n                client.DefaultRequestHeaders.Accept.Clear();\n                client.DefaultRequestHeaders.Accept.Add(\n                    new MediaTypeWithQualityHeaderValue(&quot;application/json&quot;));\n\n                IEnumerable&lt;Pokemon&gt; pokemons = Enumerable\n                .Range(1,11)\n                .Select(x =&gt; \n                {\n                    var result = client.GetAsync($&quot;http://pokeapi.co/api/v2/pokemon/{x}&quot;).Result; \n\n                    return DeserializeObject&lt;Pokemon&gt;(result.Content.ReadAsStringAsync().Result);\n                })\n                .ToList();   \n\n                foreach(var pokemon in pokemons)\n                {\n                    Console.WriteLine(pokemon.Name);\n\n                    if(pokemon.Types.Any(x =&gt; x.Type.Name.ToLower() == &quot;fire&quot;))\n                        break;\n                }\n\n            }\n\n            stopWatch.Stop();\n\n            Console.WriteLine($&quot;Tempo de execução: {stopWatch.Elapsed.Seconds} segundos&quot;);\n        }\n    }\n    public class Pokemon\n    {\n        public string Name { get; set; }\n        public IList&lt;PokemonTypeSlot&gt; Types { get; set; }\n\n        public class PokemonTypeSlot\n        {\n            public int Slot { get; set; }\n            public PokemonType Type { get; set; }\n            public class PokemonType {\n                public string Name { get; set; }\n            }\n        }\n    }\n}\n</code></pre>\n<p>Resultado:</p>\n<pre><code class=\"bash\">root@1083f7cca7e3:/app# dotnet run\nbulbasaur\nivysaur\nvenusaur\ncharmander\nTempo de execução: 36 segundos\n</code></pre>\n<p>Agora, vamos apenas tirar o <code>.ToList()</code> e permitir a chamada à API por interação (mostrarei só o trecho):</p>\n<pre><code class=\"csharp\">...\n                IEnumerable&lt;Pokemon&gt; pokemons = Enumerable\n                .Range(1,11)\n                .Select(x =&gt; \n                {\n                    var result = client.GetAsync($&quot;http://pokeapi.co/api/v2/pokemon/{x}&quot;).Result; \n\n                    return DeserializeObject&lt;Pokemon&gt;(result.Content.ReadAsStringAsync().Result);\n                });   \n\n                foreach(var pokemon in pokemons)\n                {\n                    Console.WriteLine(pokemon.Name);\n\n                    if(pokemon.Types.Any(x =&gt; x.Type.Name.ToLower() == &quot;fire&quot;))\n                        break;\n                }\n...\n</code></pre>\n<p>O resultando é bem diferente:</p>\n<pre><code class=\"bash\">root@1083f7cca7e3:/app# dotnet run\nbulbasaur\nivysaur\nvenusaur\ncharmander\nTempo de execução: 10 segundos\n</code></pre>\n<p>Vale lembrar que certamente há melhores maneiras de consumir esta API e obter o mesmo resultado, mas desenvolvi assim para explicar melhor o conceito.</p>\n<h3 id=\"Conclusao\"><a href=\"#Conclusao\" class=\"headerlink\" title=\"Conclusão\"></a>Conclusão</h3><p>Abordagens Reativas ou Pró-ativas são meios diferentes de se obter resultados numa linha de tempo. É errado perguntar quais das duas é melhor, pois dependendo do contexto é interessante utilizar um ou outro. O importante aqui é saber as diferenças e possibilidades de se trabalhar com ambas.</p>\n<p>Caso você queira, deixei meu código <a href=\"https://github.com/LuizAdolphs/blog/tree/master/codes/reactiveCollection\" target=\"_blank\" rel=\"noopener\">aqui</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}